#ifndef I2C_C
#define I2C_C
#include "i2c.h"

//*******************************************************************
// Проверка на установку частоты контроллера						*
//#ifndef I2C_C
#ifndef F_CPU													//	*
   //#error "F_CPU don't define. #defien F_CPU ???Hz"		
   #define F_CPU 1000000										//	*
#endif															//	*
//#endif
//*******************************************************************

//***********************************************************************
// Проверка максимальной скорости передачи								*
#define bitrate_max F_CPU/(16+2*10)/1000							//	*
#if (bitrate_max<=bitrate_def) 										//	*
#error "Bus I2C frequency is not supported. Reduce the frequency of the bus I2C #define bitrate_def"
#error "Частота работы шины I2C не поддерживается. Уменьшите частоты в файле i2c.h в макропределении #define bitrate_def" 
#endif																//	*
//***********************************************************************

//***********************************************************************
//	Проверка на размер Мастер-буфера									*
#ifdef Master_MODE													//	*
#if (255<Size_Master_Buf)											//	*
#error "reduce the size of the buffer Master before 255. #define Size_Master_Buf 255"
#endif																//	*
#endif																//	*
//***********************************************************************

//***********************************************************************
//	Проверка на размер Slave-буфера									*
#ifdef Slave_MODE													//	*
#if (255<Size_Slave_Buf)											//	*
#error "reduce the size of the buffer Master before 255. #define Size_Slave_Buf 255"
#endif																//	*
#endif																//	*
//***********************************************************************

//*******************************************************************
//  Статусные коды TWI модуля 										*
//*******************************************************************
//	Статусные коды начало ПЕРЕДАЧИ АДРЕСА 							*                    
//__________________________________________________________________*
// Master передал START 											*
#define TWI_START					0x08						//	*
//------------------------------------------------------------------*
// Master передал ПОВТОРНЫЙ START								//	*
#define TWI_Master_ReSTART			0x10   						//	*
//*******************************************************************
// Статусные коды ведущего передатчика								*
//	MASTER-->SLAVE													*
//__________________________________________________________________*
// Master передал АДРЕС SLA+W, а Slave предал ПОДТВЕРЖДЕНИЯ			*
// УСТРОЙСТВО с таким адресом готово к ЗАПИСИ						*
#define TWI_MTX_ADR_ACK				0x18						//	*  
//------------------------------------------------------------------*
// Master передал АДРЕС SLA+W, а Slave НЕ предал ПОДТВЕРЖДЕНИЯ		*
// Такого устройтва НЕТ НА ЛИНИИ								//	*	
#define TWI_MTX_ADR_NACK           	0x20						//	*
//------------------------------------------------------------------*
// Master передал ДАННЫЕ, а Slave передал ПОДТВЕРЖДЕНИЕ Получения	*
// Slave ГОТОВ записывать СЛЕДУЮЩИЙ БАЙТ данных в память			*
#define TWI_MTX_DATA_ACK           	0x28  						//	*
//------------------------------------------------------------------*
// Master передал ДАННЫЕ, а Slave НЕ передал ПОДТверждение Получения*
// Slave НЕ ГОТОВ записывать СЛЕДУЮЩИЙ БАЙТ в память				*
#define TWI_MTX_DATA_NACK          	0x30  						//	*
//------------------------------------------------------------------*
// был потерян приоритет											*
// одновременная передача АДРЕСА НЕСКОЛЬКИМИ Мастерами				*
#define TWI_MTX_ARB_LOST           	0x38  						//	*
//*******************************************************************
//	Статусные коды ведущего приемника								*
//	MASTER <-- SLAVE												*
//__________________________________________________________________*
// Master передал АДРЕС SLA+R, а Slave предал ПОДТВЕРЖДЕНИЯ			*
// УСТРОЙСТВО с таким адресом готово к ЧТЕНИЮ						*
#define TWI_MRX_ADR_ACK            	0x40  						//	*
//------------------------------------------------------------------*
// Master передал АДРЕС SLA+R, а Slave предал ПОДТВЕРЖДЕНИЯ			*
// УСТРОЙСТВО с таким адресом НЕ готово к ЧТЕНИЮ					*
#define TWI_MRX_ADR_NACK           	0x48  						//	*
//------------------------------------------------------------------*
// Master принял ДАННЫЕ и отправил ПОТВЕРЖДЕНИЕ Получения ДАННЫХ	*
// Master отправил ЗАПРОС на чтение СЛЕДЮУЩЕГО байта ДАННЫХ			*
#define TWI_MRX_DATA_ACK           	0x50  						//	*
//------------------------------------------------------------------*
// Master принял ДАННЫЕ и НЕ отправил ПОТВЕРЖДЕНИЕ Получения ДАННЫХ	*
// Master НЕ отправил ЗАПРОС на чтение ДАННЫХ						*
#define TWI_MRX_DATA_NACK			0x58						//	*
//------------------------------------------------------------------*
// был потерян приоритет											*
// одновременная передача АДРЕСА НЕСКОЛЬКИМИ Мастерами				*
#define TWI_MRX_ARB_LOST			0x38						//	*
//*******************************************************************
//	Статусные коды ведомого передатчика								*
//	SLAVE --> MASTER												*
//__________________________________________________________________*
//	SLAVE получил свой АДРЕС на ЧТЕНИЕ и передал ПОДТВЕРЖДЕНИЕ		*
//	SLAVE готов отправлять ДАННЫЕ Master'у							*
#define TW_STX_SLA_ACK				0xA8						//	*
//------------------------------------------------------------------*
//	SLAVE передал ДАННЫЕ, Master Передал ПОДТВЕРЖДЕНИЕ получения	*
//	Поступил ЗАПРОС SLAVE'у от Master'a на слеюующую предачу нанных	*
//	SLAVE отправляет ДАННЫЕ и проверяет наличие следующего БАЙТА	*
											//для передачи			*
#define TW_STX_DATA_ACK				0xB8						//	*
//------------------------------------------------------------------*
//	SLAVE передал ДАННЫЕ, Master НЕ Передал ПОДТВЕРЖДЕНИЕ получения	*
//	SLAVE отключается от сеанса обмена								*
#define TW_STX_DATA_NACK			0xC0						//	*
//------------------------------------------------------------------*
//	SLAVE передал ПОСЛЕДНИЙ БАЙТ ДАННЫХ,							*
						//Master Передал ПОДТВЕРЖДЕНИЕ получения	*
//	SLAVE отключается от сеанса обмена								*
#define TW_STX_LAST_DATA			0xC8 						//	*
//------------------------------------------------------------------*
//	SLAVE во время ПРЕДАЧИ получил свой АДРЕС на ЧТЕНИЕ и 			*
									//	передал ПОДТВЕРЖДЕНИЕ		*
//	Прерывается предыдущий сеанс связи и начинатся новый			*
#define TW_STX_ARB_LOST_SLA_ACK		0xB0 						//	*
//*******************************************************************
//	Статусные коды ведомого приемника								*
//	SLAVE <-- MASTER												*
//__________________________________________________________________*
//	SLAVE получил свой АДРЕС на ЗАПИСЬ и передал ПОДТВЕРЖДЕНИЕ		*
//	SLAVE готов ПРИНИМАТЬ ДАННЫЕ у Master'а							*
#define TWI_SRX_SLA_ASK			   0x60 						//	*
//------------------------------------------------------------------*
//	MASTER получил свой АДРЕС на ЗАПИСЬ и стал SLAVE'ом				*
#define TWI_SRX_ARB_LOST_SLA_ACK   0x68							//	*
//------------------------------------------------------------------*
//SLAVE получил ШИРОКОФОРМАТ АДРЕС на ЗАПИСЬ и передал ПОДТВЕРЖДЕНИЕ*
//	SLAVE готов ПРИНИМАТЬ ДАННЫЕ у Master'а							*
#define TWI_SRX_GCALL_ACK		   0x70 						//	*
//------------------------------------------------------------------*
//	Во время ШИРОКОФОРМАТНОГО СЕАНСА поступл новый ЗАПРОС на		*
			// ШИРОКОФОРМАТНЫЙ СЕАНС. Slave передал ПОДТВЕРЖДЕНИЕ	*
#define TWI_SRX_ARB_LOST_GCALL_ACK 0x78 						//	*
//------------------------------------------------------------------*
//	SLAVE получил ДАННЫЕ и Передал ПОДТВЕРЖДЕНИЕ получения			*
//	SLAVE готов принимать СЛЕДЮУЩИЙ БАЙТ ДАННЫХ						*
#define TWI_SRX_DATA_ASK		   0x80							//	*
//------------------------------------------------------------------*
//	SLAVE получил ДАННЫЕ и НЕ Передал ПОДТВЕРЖДЕНИЕ получения		*
//	SLAVE НЕ готов принимать СЛЕДЮУЩИЙ БАЙТ ДАННЫХ (нет места)		*
#define TW_SRX_DATA_NACK   		   0x88							//	*
//------------------------------------------------------------------*
//SLAVE получил ШИРОКОФОРМ ДАННЫЕ и Передал ПОДТВЕРЖДЕНИЕ получения	*
//	SLAVE готов принимать СЛЕДЮУЩИЙ БАЙТ ДАННЫХ						*
#define TWI_SRX_DATA_broad_ASK	   0x90							//	*
//------------------------------------------------------------------*
//	SLAVE получил ШИРОКОФОРМ ДАННЫЕ и НЕ Передал ПОДТВЕРЖДЕНИЕ получ*
//	SLAVE НЕ готов принимать СЛЕДЮУЩИЙ БАЙТ ДАННЫХ (нет места)		*
#define TW_SRX_GCALL_DATA_NACK      0x98						//	*
//------------------------------------------------------------------*
//	SLAVE принял ПОВТОРНЫЙ СТАРТ									*
#define TW_SRX_Slave_STOP_ReSTART	0xA0						//	*
//*******************************************************************
//	Дополнительные коды 											*
//__________________________________________________________________*
// неопределенное состояние; TWINT = “0”							*
#define TWI_NO_STATE               0xF8							//	*
//------------------------------------------------------------------*
// ошибка на шине из-за некоректного расположения СТАРТ или СТОП	*
#define TWI_BUS_ERROR              0x00							//	*
//*******************************************************************
//	Маска для упраляющего регистра								//	*
#define TWCR_CMD_MASK	0x0F									//	*
//------------------------------------------------------------------*
//	Маска источника прерывания										*
#define TWSR_STATUS_MASK 0xF8									//	*
//*******************************************************************

//*******************************************************************
// состояние шины													*
typedef enum i2c_state											//	*
{																//	*
	I2C_IDLE = 0,		// шина свободна							*
	I2C_BUSY = 1,		// шина занята								*
	I2C_MASTER_TX = 2,	// мастер-передатчик						*
	I2C_MASTER_RX = 3,	// мастер-приемник							*
	I2C_SLAVE_TX = 4,	// ведомый-передатчик						*
	I2C_SLAVE_RX = 5	// ведомый-приемник							*
} i2c_state_t;													//	*
//------------------------------------------------------------------*
#ifndef UINT16HL_T												//	*
#define UINT16HL_T												//	*
//	Доступ к младшим и старшим разрядам								*
typedef union													//	*
{																//	*
uint16_t HL;	// 16 битный регистр								*
struct{															//	*
uint8_t L;		// 8 битный регистр младший	байт					*
uint8_t H;		// 8 битный регистр старший	байт					*
};																//	*
} uint16hl_t;													//	*
#endif															//	*
//*******************************************************************


//*******************************************************************
//		Макроопределения для работы I2C c помощью ПРЕРЫВАНИЙ		*
//__________________________________________________________________*
//	Отправка СТАРТА		 											*
#define i2cSendStartI()		TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE)
//------------------------------------------------------------------*
//	Отправка  СТОПА													*
#define i2cSendStopI()		TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN)|(1<<TWIE)
//------------------------------------------------------------------*
//	Отправка  СТОПА	для приема свого АДРЕСА							*
#define i2cSendStopSlaveI();	TWCR=(1<<TWINT)|(1<<TWEA)|(1<<TWSTO)|(1<<TWEN)|(1<<TWIE)
//------------------------------------------------------------------*
//	Отправка Байта
#define i2cSendByteI(data)	do{\
TWDR=data;\
TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWIE);\
} while(0)
//------------------------------------------------------------------*
//	Отправка  ПОДТВЕРЖДЕНИЯ ASK										*	
#define i2cSendAskI()		TWCR=(1<<TWINT)|(1<<TWEA)|(1<<TWEN)|(1<<TWIE)
//------------------------------------------------------------------*
//	Отправка НЕ ПОДТВЕРЖДЕНИЯ NASK									*
#define i2cSendNAskI()		TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWIE)	//	*
//*******************************************************************

//***********************************************************************
//	Общие переменные для работы с ТВИ									*
//----------------------------------------------------------------------*
static volatile i2c_state_t I2Cstate; // Состояние шины					*
static volatile uint8_t i2cCurrentIndex=0; // Индекс переданного		*
										   // или принятого байта		*
static volatile uint8_t i2cDownloadIndex=0; // Индекс считываемого значения буфера
//----------------------------------------------------------------------*
//	Переменные для Master-Режима										*
#ifdef Master_MODE													//	*
static volatile uint8_t i2cMasterBuf[Size_Master_Buf]; //Master-буфер	*
static volatile uint8_t i2cDeviceAddrRW;	// Адрес Slave				*
static volatile uint8_t i2cMasterSendPlan=0; //Сколько мы будем отправлять	*
static volatile uint8_t i2cMasterReceivePlan=0;//Сколько скачивать будем?

#endif																//	*
//----------------------------------------------------------------------*
//	Переменные для Slave-Режима											*
#ifdef Slave_MODE
static volatile uint8_t i2cSlaveBuf[Size_Slave_Buf]; // Slave-буфер		*
static volatile uint8_t i2cSlaveIndex=0; // Индекс для записи или четния*
#endif
//***********************************************************************

//***********************************************************************
//																		*
//	Общие функции шины ТВИ												*
//																		*
//______________________________________________________________________*
//	Инициализация шины													*
void i2cInit(void)													//	*
{																	//	*
#ifdef set_pull_up_i2c												//	*
//PORT_i2c|=(1<<SCL);													//	*
//PORT_i2c|=(1<<SDA);													//	*
#endif																//	*
i2cSetBitrate(bitrate_def);											//	*
I2Cstate=I2C_IDLE;													//	*
TWCR=0;																//	*
#ifdef Slave_MODE													//	*
i2cSetDeviceAddr(i2cMyAddres, 0);									//	*
#endif																//	*
TWCR|=(1<<TWEN)|(1<<TWIE)|(1<TWINT);								//	*
sei();																//	*
}																	//	*
//----------------------------------------------------------------------*
//	Настройка частоты шины TWI											*
void i2cSetBitrate (uint16_t bitrateKHz)							//	*
{																	//	*
uint8_t TWPS_i2c=0,k=1;												//	*
uint16hl_t bitrate;													//	*
// проверяем максимальную допустимую скорость							*
if (bitrateKHz>=bitrate_max) 										//	*
{																	//	*
// Вставляем максимально-допустимую скорость работы шины				*
TWSR&=~0b11;	// Обнуляем предделитель тактирования шины ТВИ			*
TWBR=10;		// Выставляем максимальную скорость работы шины			*
return;																//	*
}																	//	*
bitrate.HL=(F_CPU/1000/bitrateKHz-16);								//	*
goto step1;															//	*
do {																//	*
TWPS_i2c++;															//	*
k=k*4;																//	*
step1:																//	*
bitrate.HL=bitrate.HL/(2*k);										//	*
} while (bitrate.HL>=0x0100);										//	*
TWSR=TWPS_i2c;														//	*
TWBR=bitrate.L;														//	*
}																	//	*
//***********************************************************************


//***********************************************************************
//																		*
//		Описание  функций в Master-РЕЖИМЕ								*
//																		*
#ifdef Master_MODE
//______________________________________________________________________*
//	Сброс указателя Master-буфера										*
void i2cMasterBufReset(void)										//	*
{																	//	*
i2cMasterSendPlan=0;	// обнуляем счетчик байт для отправки 			*
i2cMasterReceivePlan=0; // обнуляем счетчик байт для приема				*
}																	//	*
//----------------------------------------------------------------------*
//----------------------------------------------------------------------*
//	Загрузка ДАННЫХ в Master-буфер для ОТПРАВКИ							*
//	Результат функции успешность загрузки данных в буфер				*
uint8_t i2cMasterUploadBuf(uint8_t data)							//	*
{																	//	*
if (i2cMasterSendPlan<Size_Master_Buf)								//	*
	{																//	*
	i2cMasterBuf[i2cMasterSendPlan]=data;							//	*
	i2cMasterSendPlan++;											//	*
	return 1;														//	*
	}																//	*
	else															//	*
	{																//	*
	// i2cMasterSendPlan == Size_Master_Buf								* 
	return 0;														//	*
	}																//	*
}																	//	*
//----------------------------------------------------------------------*
//	Отправка данных из Master-буфера									*
//	Результат функции кол-во отправленных байт							*
uint8_t i2cMasterSendBuf(uint8_t deviceAdd)							//	*
{																	//	*
while(I2Cstate); 		// Ожидаем освобождения шины 					*
I2Cstate=I2C_MASTER_TX; // Устанавливаем флаг  предачи мастером 		*
i2cDeviceAddrRW=(deviceAdd<<1);	// Загружаем Slave АДРЕС+W				*
i2cSendStartI();		// Посылаем команду старта передачи				*
while(I2Cstate); 		// Ожидаем освобождения шины 					*
i2cMasterSendPlan=0;	// Все байты отправлены							*
return i2cCurrentIndex; // Кол-во успешно отправленных байт				*
}																	//	*
//----------------------------------------------------------------------*
//	Чтение данных из Slave												*
//	Перед чтение происходит запись данных из Мастер-Буфера				*
//	Результат функции кол-во принятых байт								*
uint8_t i2cMasterReceive(uint8_t deviceAdd, uint8_t lenght)			//	*
{																	//	*
while(I2Cstate); 		// Ожидаем освобождения шины					*
i2cMasterReceivePlan=lenght; // Планируется принять						*
// ПРоверяем требуется ли что-то передать из буфера Мастера				*
if (i2cMasterSendPlan) 												//	*
	{																//	*
	// В буфере что-то есть. Скорее всего это адрес						*
	i2cMasterSendBuf(deviceAdd);									//	*
	}																//	*
	else															//	*
	{																//	*
	I2Cstate=I2C_MASTER_RX; // Устанавливаем флаг приема мастером		*
	i2cDeviceAddrRW=(deviceAdd<<1)|(1);								//	*
	i2cSendStartI();												//	*
	while(I2Cstate); 		// Ожидаем освобождения шины			//	*
	i2cMasterBufReset();// Сброс Буфера мастера							*
	}																//	*
return i2cCurrentIndex;												//	*
}																	//	*
//----------------------------------------------------------------------*
//	ПОСЛЕДОВАТЕЛЬНОЕ чтение ДАННЫХ из Master-буфер после ПРИЕМА			*
//	Результат функции успешность чтения данных из буфера				*
/*
uint8_t i2cMasterDownloadBuf(uint8_t * result)						//	*
{																	//	*
*result=i2cMasterBuf[i2cDownloadIndex++];							//	*
if (i2cDownloadIndex<=i2cCurrentIndex)								//	*
	{																//	*
	return 1;														//	*
	}																//	*
else																//	*
	{																//	*
	i2cDownloadIndex=0;												//	*
	return 0;														//	*
	}																//	*
}																	//	*
*/
//----------------------------------------------------------------------*
//	ИНДЕКНОЕ чтение ДАННЫХ из Master-буфер после ПРИЕМА					*
//	Результат функции успешность чтения данных из буфера				*
uint8_t i2cMasterDownloadBufIndex(uint8_t* result, uint8_t index)	//	*
{																	//	*
if (index<Size_Master_Buf) 											//	*
	{																//	*
	*result=i2cMasterBuf[index];									//	*
	return 1;														//	*
	}																//	*
else																//	*
	{																//	*
	return 0;														//	*
	}																//	*
}																	//	*
#endif
//***********************************************************************


//***********************************************************************
//																		*
//		Описание  функций в Slave-РЕЖИМЕ								*
//																		*
#ifdef  Slave_MODE
//______________________________________________________________________*
//	Настройка АДРЕСА шины ТВИ											*
void i2cSetDeviceAddr(uint8_t deviceAddr, uint8_t Broadcast)		//	*
{																	//	*
TWAR=((deviceAddr&0x7F)<<1)|(Broadcast&0x1); // настраиваем адрес и		*
											 // и широкоформатную адрес	*
TWCR=(1<<TWEA);	// Включаем отзыв на адрес							//	*
}																	//	*
//----------------------------------------------------------------------*
// Загрузка значений в Slave буфер										*
// Результат функции успешность загрузки								*
uint8_t i2cSlaveUploadBuf(uint8_t data, uint8_t index)				//	*
{
if (index<Size_Slave_Buf)											//	*
	{																//	*
	i2cSlaveBuf[index]=data;										//	*
	return 1;														//	*
	}																//	*
	else															//	*
	{																//	*
	return 0;
	}																//	*
}
//----------------------------------------------------------------------*
// Считывание значений из Slave буфера									*
// Результат функции успешность считывания								*
uint8_t i2cSlaveDownloadBuf(uint8_t* result, uint8_t index)		//	*
{
if (index<Size_Slave_Buf) 											//	*
	{																//	*
	*result=i2cSlaveBuf[index];										//	*
	return 1;														//	*
	}																//	*
else																//	*
	{																//	*
	return 0;														//	*
	}																//	*
}
#endif
//***********************************************************************


//***********************************************************************
//																		*
//		Обработчик прерываний шины TWI									*
//																		*
//***********************************************************************
ISR(TWI_vect)														//	*
{																	//	*
uint8_t status=(TWSR&TWSR_STATUS_MASK);	// считываем КОД прерывания		*
switch(status)				// Обрабатываем КОД прерывания				*
{																	//	*
//***********************************************************************
//																		*
//		Master отправляет АДРЕС SLAVE'у									*
//																		*
#ifdef Master_MODE
//----------------------------------------------------------------------*
case TWI_START:	 	 // 0х08 состояние START отправленно				* 	
case TWI_Master_ReSTART:// 0х10 состояние повторный START отправленно	*
	i2cSendByteI(i2cDeviceAddrRW);// отправляем АДРЕС SLAVE				*
break; 				// выход из прерывания								*
//***********************************************************************
//																		*
//							MASTER-ПЕРЕДАТЧИК							*
//																		*
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
//	Master передал SLAVE'у АДРЕС+W. Slave передал ГОТОВНОСТЬ К ПРИЕМУ 	*
//----------------------------------------------------------------------*
case TWI_MTX_ADR_ACK: // 0х18 Получено подтверждение адреса				*
	i2cCurrentIndex=0; // Обнуляем текущий индекс отправляемого байта	*
//======================================================================*
//	Master передал ДАННЫЕ, Slave готов к ПРИЕМУ СЛЕДУЮЩЕГО БАЙТА		*
//----------------------------------------------------------------------*
case TWI_MTX_DATA_ACK:// 0х28 Slave ГОТОВ к ПРИЕМУ ДАННЫХ				*
	// ПРОВЕРЯЕМ наличие байтов для ОТПРАВКИ							* 
	if (i2cCurrentIndex<i2cMasterSendPlan) 							//	*
	{																//	*
		i2cSendByteI(i2cMasterBuf[i2cCurrentIndex++]);// Загружаем БАЙТ	*
	}											  // и отправляем		*
	else															//	*
	{																//	*
		// все байт переданы											*
		// Теперь Проверяем необходимость приема данных					*
		if (!(i2cMasterReceivePlan))								//	*
		{															//	*
		// Принимать ничего не требуется								*
		#ifdef Slave_MODE											//	*
		i2cSendStopSlaveI();;// отправляем СТОП с дальнейшим приемом АДРЕС
		#else														//	*
		i2cSendStopI();		// отправляем СТОП							*
		#endif														//	*
		I2Cstate=I2C_IDLE;	// флаг шины выставляем в ожидании			*
		}															//	*
		else														//	*
		{															//	*
		// Нам необходимо принять байты									*
		i2cDeviceAddrRW|=1; // Редактируем адрес на чтение				*
		i2cSendStartI();	// Отправляем ПОВТОРНЫЙ СТАРТ				*
		}															//	*
	}																//	*
break; 				// выход из прерывания								*
					// Конец автомата Записи в Slave					*
//***********************************************************************
//																		*
//							MASTER-ПРИЕМНИК								*
//																		*
//======================================================================*
//	Master передал АДРЕС-ЧТЕНИЕ. Slave передал ГОТОВНОСТЬ К ПЕРЕДАЧИ 	*
//----------------------------------------------------------------------*
case TWI_MRX_ADR_ACK:  //0х40 Slave выдал ПОДТВЕРЖДЕНИЕ на				* 
					   //	  принятый АДРЕС+R							*
	i2cCurrentIndex=0;	// Текущий адрес принимаемого байта				*
	// Проверяем что делать дальше										*
	switch(i2cMasterReceivePlan)									//	*
	{																//	*
	case 0: 														//	*
			#ifdef Slave_MODE										//	*
			i2cSendStopSlaveI();	// отправляем СТОП с приемом АДРЕС	*
			#else													//	*
			i2cSendStopI();		// отправляем СТОП						*
			#endif													//	*
			I2Cstate=I2C_IDLE;	// флаг шины выставляем в ожидании		*
			break;													//	*
	case 1:	i2cSendNAskI();// Master запросит только 1 байт				*
			break;													//	*
	default: i2cSendAskI(); // Master запросит при приеме СЛЕДУЮЩИЙ БАЙТ*
			break;													//	*
	}																//	*
break;  // выход из прерывания											*
//======================================================================*
//	Master принял ДАННЫЕ и отравил запрос SLAVE на ПЕРЕДАЧУ СЛЕД. БАЙТА	* 
//----------------------------------------------------------------------*
case TWI_MRX_DATA_ACK: //0х50 Мастер отправил запрос на СЛЕД. ПЕРЕДАЧ 	*
	i2cMasterBuf[i2cCurrentIndex++]=TWDR; // Копируем ДАННЫЕ			*
	// ПРоверка на принятие последнего БАЙТ ПОСЛЕДНИЙ					*
	if (i2cCurrentIndex<i2cMasterReceivePlan-1)						//	*
	// Это не последний ПРИНИМАЕМЫЙ БАЙТ								*
	i2cSendAskI(); // Master запросит при приеме СЛЕДУЮЩИЙ БАЙТ			*
	else															//	*
	// Это последний принятый быйт									//	*
	i2cSendNAskI();// Master не отправит подтверждение на следующий БАЙТ*
				  // Master принмет ПОСЛЕДНИЙ БАЙТ						*
break;																//	*
//======================================================================*
//	Master+R принял ДАННЫЕ и НЕ передал ПОДТВЕРЖДЕНИЯ					*
//----------------------------------------------------------------------*
case TWI_MRX_DATA_NACK: // 0х58 Получен последний байт данных 			*
						//      от ведомого устройства, 				*
						//		МАСТЕР НЕ отправил ПОДТВЕРЖДЕНИЕ 		*
						//												*
	i2cMasterBuf[i2cCurrentIndex++]=TWDR; // копируем последний			*
						//		байт в приемный буфер					*
	i2cMasterReceivePlan=0;	// Все данные переданны, Отправлять нечего	*
//======================================================================*
//																		*
//					ОКОНЧАНИЕ ПРИЕМА И ПЕРЕДАЧИ МАСТЕРА					*
//																		*
//----------------------------------------------------------------------*
//	Master передал АДРЕС+R, Slave не отправил  ПОДТВЕРЖДЕНИЯ			*
//----------------------------------------------------------------------*
case TWI_MTX_DATA_NACK://0х30 Подтверждение переданных ДАННЫХ Не Получено
//----------------------------------------------------------------------*
case TWI_MRX_ADR_NACK: //0х48 Подтверждение АДРЕСа на ЧТЕНИЕ Не Получено*
//======================================================================* 
//	Master передает АДРЕС-ЗАПИСЬ или ДАННЫЕ, Slave НЕ передает ПОДТВЕРЖД*
//----------------------------------------------------------------------* 
case TWI_MTX_ADR_NACK: //0х20 Подтверждение АДРЕСа на ЗАПИСЬ Не Получено*
	#ifdef Slave_MODE												//	*
	i2cSendStopSlaveI();	// отправляем СТОП с приемом АДРЕС				*
	#else															//	*
	i2cSendStopI();		// отправляем СТОП								*
	#endif															//	*
	I2Cstate=I2C_IDLE; // СОСТОЯНИЕ АВТОМАТА в ОЖИДАНИЕ					*
break; // выход из прерывания											*
#endif	// окончание включения Master Режима							*
//***********************************************************************
//***********************************************************************
//***********************************************************************
//	Потеря арбитража													*
//----------------------------------------------------------------------* 
case TWI_MTX_ARB_LOST:												//	*
	TWCR=(1<<TWINT)|(1<<TWSTA)|(TWCR&TWCR_CMD_MASK);				//	*
	I2Cstate=I2C_IDLE; // СОСТОЯНИЕ АВТОМАТА в ОЖИДАНИЕ					*
break;  // выход из прерывания											*
//***********************************************************************
#ifdef  Slave_MODE													//	*
//======================================================================*
//	Включаем режим ВЕДОМОГО												*
//***********************************************************************
//***********************************************************************
//***********************************************************************
//***********************************************************************
//																		*
//					SLAVE+W		Ведомый-Приемник						*
//																		*
//======================================================================*
//Slave+W - ПРИЕМНИК. Slave принял свой АДРЕС+W и отправил ПОДТВЕРЖДЕНИЕ* 
//======================================================================*
case TWI_SRX_SLA_ASK:  		   // 0x60 принят свой адрес на ЗАПИСЬ		*
case TWI_SRX_ARB_LOST_SLA_ACK: // 0x68 Прием своего АДРЕСА во время 	*
							   //      работы МАСТЕРОМ					*
case TWI_SRX_GCALL_ACK:		   // 0x70 принят широковещательный aдрес 	*
							   //	   на запись						*
case TWI_SRX_ARB_LOST_GCALL_ACK://0x78 передача широковещательного пакет* 
							   //	   во время работы МАСТЕРОМ			*
	I2Cstate=I2C_SLAVE_RX;	   // Состояние ФЛАГа передачи				*
	i2cCurrentIndex=0;        // Обнуление индекса принятого байта		*
	i2cSendAskI();			   //Включаем ПОДТверждение на прияный адрес*
break;// выход из прерывания											*
//======================================================================*
//	Slave+W приняли ДАННЫЕ с ПОДТВЕРЖДЕНИЕМ								*
case TWI_SRX_DATA_ASK:  	// 0x80 принят байт Данных с ПОДТверждением	*
case TWI_SRX_DATA_broad_ASK:// 0x90 принят байт широковещательный		*
	// Сохранение принятых данных										*
	if (!(i2cCurrentIndex)) 
	{
	i2cSlaveIndex=TWDR;
	i2cCurrentIndex=1;
	goto slave_w;
	}

	i2cSlaveBuf[i2cSlaveIndex++]=TWDR;								//	*
	//i2cSlaveIndex++;
	slave_w:
	// Определение ВОЗМОЖНОСТИ подтверждения следующего БАЙТА			*
	if (i2cSlaveIndex<Size_Slave_Buf-1)								//	*
		{															//	*
		i2cSendAskI();		 // Следующий байт примем с ПОДТверждением	*
		}															//	*
	else															//	*
		{															//	*
		i2cSendNAskI(); 	// Следующий байт примем БЕЗ ПОДТверждения	*
		}															//	*
break;// выход из прерывания											*
//======================================================================*
//	Slave+W прининял ДАННЫЕ БЕЗ ПОДТВЕРЖДЕНИЯ							*
case TW_SRX_DATA_NACK: 		// 0x88 приняли последний байт 				*
							//		без подтверждения					*
case TW_SRX_GCALL_DATA_NACK:// 0x98 приняли последний 					*
							//		байт широковещательный				*
	if (i2cSlaveIndex<Size_Slave_Buf)								//	*
		i2cSlaveBuf[i2cSlaveIndex]=TWDR;//Сохранение Данных				*
	i2cSendNAskI();			// Отпускаем линию							*
break;// выход из прерывания											*
//***********************************************************************
//						Slave+R - Ведомый ПЕРЕДАТЧИК					*
//======================================================================*
//	Slave+R принял свой АДРЕС+R и отправил ПОДТВЕРЖДЕНИЕ	
case TW_STX_SLA_ACK:// 0xA8 Получен пакет SLA+R и передано подтверждение*
case TW_STX_ARB_LOST_SLA_ACK:// 0xB0 Получен широкформат пакет SLA+R 	*
							 //		 и передано подтверждение			*
	I2Cstate=I2C_SLAVE_TX;	 // Состояние ФЛАГа передачи				*
	i2cCurrentIndex=0; 		 // 										*
//======================================================================*
//	Slave+R отправил данные Master'у									*
//======================================================================*
case TW_STX_DATA_ACK:		 // 0xB8 Slave передал ДАННЫЕ				*
							 //		 Master получил данные и отправил ASK
	if(i2cSlaveIndex<Size_Slave_Buf)
	{
	// Загружаем БАЙТ ДАННЫХ в регистр для отправки						*
	TWDR=i2cSlaveBuf[i2cSlaveIndex++];							//	*
	}																//	*
	//	ПЕРЕДАВАЕМЫЙ БАЙТ ПОСЛЕДНИЙ?									*
	if (i2cSlaveIndex<Size_Slave_Buf)							//	*
	i2cSendAskI();			 // ПЕРЕДАЕМ НЕ ПОСЛЕДИНЙ БАЙТ		 		*
	else															//	*
	i2cSendNAskI();			 // ПЕРЕДАЕМ ПОСЛЕДНИЙ БАЙТ					*	
break; 						 // выход из прерывания						*
//======================================================================*
//	Slave+R окончание передачи 											*
case TW_STX_DATA_NACK:	 // 0xC0 Передан байт ДАННЫХ и 					*
						//       Мастеру больше данных НЕ НУЖНО (NASK)	* 
case TW_STX_LAST_DATA:	 // 0xC8  Последний байт передан, а 			*
						// Мастер запрашивает новые данные (ASK)		*	
	i2cSendAskI();		 // Отпускаем линию SCL и Ждем свой АДРЕС*
	I2Cstate=I2C_IDLE;	// Состояние ФЛАГа автомата в ОЖИДАНИИ			*
break;																//	*
//======================================================================*
//	Прием Повторного Старта или Стоп									*
case TW_SRX_Slave_STOP_ReSTART:	// 0xA0 Принят СТОП или ПОВТОРНЫЙ СТАРТ	*
	i2cSendAskI();				// Дальнейший Прием с подтверждением	*
	I2Cstate=I2C_IDLE;			// Состояние ФЛАГа передачи				*
break; 							// выход из прерывания					*
//======================================================================*
#endif	// Включаем Слейв режим										//	*
//***********************************************************************
//***********************************************************************
//	Дополнительные КОДЫ прерываний 										*
//----------------------------------------------------------------------*
case TWI_NO_STATE:  // 0xF8 неопределенное состояние; TWINT = “0”		*
break;																//	*
//----------------------------------------------------------------------*
case  TWI_BUS_ERROR:	// 	0x00 ошибка на шине из-за 					*
						//	некоректного расположения СТАРТ или СТОП	*
	i2cSendStopI();		//	ОТПРАВИЛИ СТОП								*
	I2Cstate=I2C_IDLE;	// 	Состояние ФЛАГа автомата в ОЖИДАНИИ			*
break;																//	*
//***********************************************************************
}	//	Конец Case														*
}	//	конец прерывания TWI											*
//***********************************************************************
#endif
